
Linux网络栈解剖

原文：[Anatomy of the Linux networking stack](http://140.120.7.21/LinuxRef/Network/LinuxNetworkStack.html)。最早应该是在IBM的Developerworks上的，但现在原始链接已经失效了。

大部分是Google机器翻译的。Google翻译实际已经比一般水平的翻译者要靠谱的多，只是某些特定用法需要调整下。

我会参照这篇文章写一个Linux内核网络协议栈的文章，大部分是。

---

Linux®操作系统的最大功能之一是其网络堆栈。它最初是BSD堆栈的衍生物，并且组织良好，具有一组干净的接口。其接口范围从协议无关接口（如通用套接字层接口或设备层）到各个网络协议的特定接口。本文从网络栈各层的角度探讨了Linux网络堆栈的结构，并探讨了其一些主要结构体。

### 协议介绍

虽然网络的正式介绍通常是指开放系统互连（OSI）模型，但是Linux中基本网络堆栈的介绍使用互联网模型的四层模型（参见图1）。

![图1](http://7xir15.com1.z0.glb.clouddn.com/ANS-figure1.gif)

网络栈的底部是链路层。链路层是指提供访问物理层的设备驱动程序（物理层可以是各种各样的介质，诸如串行链路或以太网设备）。链路层上面是网络层，负责将数据包引导到目的地。下一层是传输层，它负责点对点通信（例如，在主机内）。正如网络层管理主机之间的通信，传输层管理这些主机之间的端点(Endpoint)之间的通信。最后是应用层，即可以理解所传输的数据的语义层。

### 核心网络架构

现在讨论Linux网络栈的架构以及它如何实现Internet模型。图2提供了Linux网络堆栈的高级视图。顶部是定义网络栈用户的用户空间层或应用层。底部是提供与网络（串行或高速网络（如以太网））连接的物理设备。在中间的内核空间，是本文重点要讨论的网络子系统。通过网络栈的内部流量套接字缓冲区（sk_buffs），它们在源和目的之间移动数据包数据。你很快会看到sk_buff结构。

![图2](http://7xir15.com1.z0.glb.clouddn.com/ANS-figure2.gif)

首先简要介绍Linux网络子系统的核心元素，后面会有更详细的介绍。在顶部（见图2）是系统调用接口。这只是为用户空间应用程序提供访问内核网络子系统的一种方式。接下来是一个协议无关的层，提供了一种常用的方法来处理底层的传输层协议。接下来是实际的协议，在Linux中包括TCP，UDP和IP的内置协议。接下来是另一个设备无关的层，它允许使用通用接口与单个设备驱动程序交互，之后是各个设备驱动程序本身。

http://7xir15.com1.z0.glb.clouddn.com/ANS-figure3.gif
http://7xir15.com1.z0.glb.clouddn.com/ANS-figure4.gif

### 系统调用接口

系统调用接口可以从两个角度进行描述。当用户进行网络调用时，通过系统调用接口多路复用到内核中。这最终作为 sys_socketcall(./net/socket.c)中的调用，然后进一步解复用到其预期目标的调用。系统调用接口的另一个角度是使用正常的文件操作进行网络I / O。例如，典型的读写操作可以在网络套接字（由文件描述符表示，就像普通文件）一样执行。因此，虽然存在一些特定于网络的操作（创建具有socket呼叫的套接字，将其连接到具有connect呼叫的目的地等等），还有一些适用于网络对象的标准文件操作，就像常规文件一样。最后，系统调用接口提供了在用户空间应用程序和内核之间传输控制的手段。


协议无关接口

套接字层是协议无关接口，提供一组通用功能，以支持各种不同的协议。套接字层不仅支持典型的TCP和UDP协议，还支持IP，原始以太网和其他传输协议，如流控制传输协议（SCTP）。

通过网络堆栈进行通信，并使用套接字。Linux中的套接字结构struct sock是在linux / include / net / sock.h中定义的。该大型结构包含特定套接字的所有必需状态，包括套接字使用的特定协议以及可能在其上执行的操作。

网络子系统通过定义其功能的特殊结构了解可用的协议。每个协议维护一个名为proto（在linux / include / net / sock.h中找到）的结构。该结构定义了可以从套接字层到传输层执行的特定套接字操作（例如，如何创建套接字，如何与套接字建立连接，如何关闭套接字等）。


网络协议

网络协议部分定义了可用的特定网络协议（如TCP，UDP等）。这些是inet_init在linux / net / ipv4 / af_inet.c中调用的一个函数的开头进行初始化的（因为TCP和UDP是协议 inet族的一部分）。该 inet_init功能使用该 功能注册每个内置协议proto_register。此功能在linux / net / core / sock.c中定义，除了将协议添加到活动协议列表之外，还可以根据需要分配一个或多个slab缓存。

您可以通过protolinux / net / ipv4 /中的文件tcp_ipv4.c，udp.c和raw.c中的结构来了解各自的 协议。这些协议结构中的每一个都按照类型和协议inetsw_array进行映射，将内部协议映射到其操作。其结构 inetsw_array及其关系如图3所示。该数组中的每个协议都在初始化时inetsw通过调用 inet_register_protoswfrom 来初始化 inet_init。功能 inet_init还初始化各种 inet模块，如ARP，ICMP，IP模块，TCP和UDP模块。


图3. Internet协议数组的结构



Socket协议关联
回想当创建一个套接字时，它定义了类型和协议，如 my_sock = socket( AF_INET, SOCK_STREAM, 0 )。该 AF_INET表示基于Internet地址族定义为流式套接字SOCK_STREAM（如下所示 inetsw_array）。

从图3可以看出， proto结构定义了传输特定方法，而proto_ops结构定义了一般的套接字方法。可以inetsw通过调用将附加协议添加到 协议交换机 inet_register_protosw。例如，SCTP通过sctp_init在linux / net / sctp / protocol.c中的调用来添加自身。有关SCTP的更多信息，请参阅 参考资料部分。

套接字的数据移动使用称为套接字缓冲区（sk_buff）的核心结构进行。一个sk_buff 包含的分组数据，并且还覆盖协议栈的多个层的状态数据。发送或接收的每个数据包都用一个表示 sk_buff。该sk_buff 结构是在linux定义/包括/ LINUX / skbuff.h中，并在图4中示出。


图4. Socket缓冲区及其与其他结构的关系


如图所示，sk_buff给定连接可以将多个链接在一起。每个sk_buff标识net_device要发送数据包或从其接收数据包的设备结构（）。由于每个分组与表示 sk_buff，数据包报头可方便地通过一组指针（的位于th， iph以及mac用于媒体访问控制或MAC报头）。由于sk_buff 是套接字数据管理的核心，因此已经创建了许多支持功能来管理它们。存在用于sk_buff 创建和销毁，克隆和队列管理的功能。

套接字缓冲器被设计为为给定的套接字链接在一起，并且包括许多信息，包括到协议头的链接，时间戳（发送或接收数据包时）以及与数据包相关的设备。


设备不可知接口

协议层下面是另一个不可知的接口层，将协议连接到具有不同功能的各种硬件设备驱动程序。该层提供了一组通用的功能，由较低级别的网络设备驱动程序使用，以允许它们使用较高级协议栈进行操作。

首先，设备驱动程序可以通过调用register_netdevice或 注册自己注册到内核unregister_netdevice。呼叫者首先填写 net_device结构，然后将其传入进行注册。内核调用其init功能（如果定义了一个），执行许多健全检查，创建一个 sysfs条目，然后将新设备添加到设备列表（在内核中活动的设备的链表）。你可以 net_device在linux / include / linux / netdevice.h中找到结构。各种功能在linux / net / core / dev.c中实现。

要从sk_buff协议层发送到设备，使用该dev_queue_xmit功能。该功能sk_buff为底层设备驱动程序（网络设备由...定义net_device或sk_buff->dev 引用）中的最终传输进行 排队sk_buff。该 dev结构包含一个称为 hard_start_xmit，保存用于启动传输的驱动程序功能的方法sk_buff。

常规地执行接收分组 netif_rx。当下级设备驱动程序接收到一个分组（包含在分配的sk_buff）中时， sk_buff通过调用传递给网络层netif_rx。然后，该功能将其排队 sk_buff到上层协议的队列以进行进一步处理netif_rx_schedule。您可以 在linux / net / core / dev.c 中找到 dev_queue_xmit和netif_rx使用。

最近，在内核中引入了一个新的应用程序接口（NAPI），以允许驱动程序与设备不可知层（dev）进行接口。一些驱动程序使用NAPI，但绝大多数仍然使用较旧的帧接收接口（由6到1的粗略因素）。NAPI可以通过避免每个传入帧的中断，在高负载下产生更好的性能。


设备驱动程序

网络堆栈的底部是管理物理网络设备的设备驱动程序。该层的设备示例包括串行接口上​​的SLIP驱动程序或以太网设备上的以太网驱动程序。

在初始化时，设备驱动程序分配一个 net_device结构，然后用其必需的例程进行初始化。调用这些例程之一 dev->hard_start_xmit定义了上层如何排队sk_buff传输。这个程序需要的sk_buff。此功能的操作取决于底层硬件，但通常将描述的数据包sk_buff移动到硬件环或队列。如设备不可知层所述，帧接收使用该 netif_rx接口或 netif_receive_skb符合NAPI的网络驱动程序。NAPI驱动程序对底层硬件的功能提出了约束。有关详细信息，请参阅参考资料部分。

在设备驱动程序配置其结构中的 dev接口后，调用 register_netdevice它可以使用。您可以在linux / drivers / net中找到网络设备专用的驱动程序。


进一步

Linux源代码是了解许多设备类型（包括网络设备驱动程序）的设备驱动程序设计的好方法。您可以找到可用内核API的设计和使用方面的变化，但每个都可用于指令或作为新设备驱动程序的起点。网络堆栈中的剩余代码是常见且可用的，除非您需要新的协议。即使这样，TCP（用于流协议）或UDP（用于基于消息的协议）的实现也是用于开始新开发的有用模型。











---
