<!DOCTYPE HTML>
<html>
<head>
  <meta name="baidu-site-verification" content="mFmscoluqW" />
  <meta charset="utf-8">
  
  <title>MapReduce具体问题（一） | 伊布</title>
  <meta name="author" content="hubt@dtdream.com">
  
  <meta name="description" content="MapReduce比较基础，但是经常会有一些问题不是很清楚，这一系列文章会解答几个经常问的问题。本文解答第一个问题：是谁决定要起几个Map任务？在什么阶段呢？">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="MapReduce具体问题（一）"/>
  <meta property="og:site_name" content="伊布"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/github.ico" rel="icon" type="image/x-ico">
  <link rel="alternate" href="/atom.xml" title="伊布" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  


  <script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?28bfa356a7c60e170822a01142cf208e";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

<script>
var option = {
  engineKey: 'f3e1951e888b8a117845'
};
(function(w,d,t,u,n,s,e){
  s = d.createElement(t);
  s.src = u;
  s.async = 1;
  w[n] = function(r){
    w[n].opts = r;
  };
  e = d.getElementsByTagName(t)[0];
  e.parentNode.insertBefore(s, e);
})(window,document,'script','//tinysou-cdn.b0.upaiyun.com/ts.js','_ts');
_ts(option);
</script>

</head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">伊布</a></h1>
  <h2><a href="/"></a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">Home</a></li>
    
      <li><a href="/archives">Archives</a></li>
    
      <li><a href="/About">About</a></li>
    
	<li> <a href="/atom.xml">RSS</a> </li>
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div></header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper"><article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-05-25T00:44:33.000Z"><a href="/2015/05/25/mr-detail-1/">2015-05-25</a></time>
      
      
  
    <h1 class="title">MapReduce具体问题（一）</h1>
  

    </header>
    <div class="entry">
      
        <p>MapReduce比较基础，但是经常会有一些问题不是很清楚，这一系列文章会解答几个经常问的问题。<br>本文解答第一个问题：是谁决定要起几个Map任务？在什么阶段呢？<br><a id="more"></a></p>
<p>还是以wordcount为例。<br>wordcount客户端在初始化job后调用Job.waitForCompletion方法就结束了，真正提交Job给Yarn的在MapReduce客户端代码的submit里做的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">waitForCompletion</span><span class="params">(<span class="keyword">boolean</span> verbose</span><br><span class="line">                                 )</span> <span class="keyword">throws</span> IOException, InterruptedException,</span><br><span class="line">                                          ClassNotFoundException </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (state == JobState.DEFINE) &#123;</span><br><span class="line">    submit();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">submit</span><span class="params">()</span></span><br><span class="line">      return submitter.<span class="title">submitJobInternal</span><span class="params">(Job.<span class="keyword">this</span>, cluster)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">JobStatus <span class="title">submitJobInternal</span><span class="params">(Job job, Cluster cluster)</span></span><br><span class="line">    <span class="comment">// Create the splits for the job</span></span><br><span class="line">    LOG.<span class="title">debug</span><span class="params">(<span class="string">"Creating splits at "</span> + jtFs.makeQualified(submitJobDir)</span>)</span>;</span><br><span class="line">    <span class="keyword">int</span> maps = writeSplits(job, submitJobDir);</span><br><span class="line">    conf.setInt(MRJobConfig.NUM_MAPS, maps);		<span class="comment">//确定MR任务数</span></span><br><span class="line">    LOG.info(<span class="string">"number of splits:"</span> + maps);</span><br></pre></td></tr></table></figure>
<p>从上面的代码不难看出，Map任务的个数是客户端提交任务到YARN之前就决定了的，其个数由writeSplits结果决定。<br>那么Splits是什么？跟HDFS有什么关系呢？</p>
<p>我们知道，HDFS存储大文件的时候，将文件按照每64MB（或者128MB，可以配置）分为若干个块（Block），每个Block又分了若干个副本，分别存储到不同的datanode上去。而在做MapReduce的时候，我们希望能够获得比较好的数据本地性，也就是说计算任务跟它需要的数据，最好在一个节点上，从而可以显著的减少数据在网络上的传输。<br>结合上面两点，不难得出一个结论，Map任务的个数（计算任务），实际应该是由MR处理的文件在HDFS上存储的块的个数决定的。</p>
<p>回过头来分析writeSplits，它调用了writeNewSplits。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JobSubmitter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> &lt;T extends InputSplit&gt;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">writeNewSplits</span><span class="params">(JobContext job, Path jobSubmitDir)</span> <span class="keyword">throws</span> IOException,</span><br><span class="line">      InterruptedException, ClassNotFoundException </span>&#123;</span><br><span class="line">    Configuration conf = job.getConfiguration();</span><br><span class="line">    InputFormat&lt;?, ?&gt; input =		<span class="comment">//先获取input的格式</span></span><br><span class="line">      ReflectionUtils.newInstance(job.getInputFormatClass(), conf);</span><br><span class="line"></span><br><span class="line">    List&lt;InputSplit&gt; splits = input.getSplits(job);		<span class="comment">//根据格式获取分片数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">InputFormat</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span></span><br><span class="line">    List&lt;InputSplit&gt; <span class="title">getSplits</span><span class="params">(JobContext context</span><br><span class="line">                               )</span> <span class="keyword">throws</span> IOException, InterruptedException</span>;</span><br></pre></td></tr></table></figure></p>
<p>writeNewSplits先获取input的格式（其实就是根据文件后缀名来判断的，例如gz, bzip2等等），然后再根据对应的格式对象里的getSplits来获取分片数。本例里wordcount要处理的就是一个“纯文本文件”，对应的FileInputFormat是InputFormat的一种。<br>下面我们以FileInputFormat来看getSplits是怎么获取分片数的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">FileInputFormat</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">InputFormat</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isSplitable</span><span class="params">(JobContext context, Path filename)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;InputSplit&gt; <span class="title">getSplits</span><span class="params">(JobContext job)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> minSize = Math.max(getFormatMinSplitSize(), getMinSplitSize(job));	<span class="comment">//最小值，1</span></span><br><span class="line">    <span class="keyword">long</span> maxSize = getMaxSplitSize(job);	<span class="comment">//最大值，Long.MAX_VALUE</span></span><br><span class="line">..</span><br><span class="line">        <span class="keyword">if</span> (isSplitable(job, path)) &#123;		<span class="comment">//如果输入可分片</span></span><br><span class="line">          <span class="keyword">long</span> blockSize = file.getBlockSize();		<span class="comment">//HDFS的block大小</span></span><br><span class="line">          <span class="keyword">long</span> splitSize = computeSplitSize(blockSize, minSize, maxSize);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">long</span> bytesRemaining = length;</span><br><span class="line">          <span class="keyword">while</span> (((<span class="keyword">double</span>) bytesRemaining)/splitSize &gt; SPLIT_SLOP) &#123;</span><br><span class="line">            <span class="keyword">int</span> blkIndex = getBlockIndex(blkLocations, length-bytesRemaining);</span><br><span class="line">            splits.add(makeSplit(path, length-bytesRemaining, splitSize,</span><br><span class="line">                        blkLocations[blkIndex].getHosts(),		<span class="comment">//注意getHosts</span></span><br><span class="line">                        blkLocations[blkIndex].getCachedHosts()));</span><br><span class="line">            bytesRemaining -= splitSize;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (bytesRemaining != <span class="number">0</span>) &#123;	<span class="comment">//最后一个小分片</span></span><br><span class="line">            <span class="keyword">int</span> blkIndex = getBlockIndex(blkLocations, length-bytesRemaining);</span><br><span class="line">            splits.add(makeSplit(path, length-bytesRemaining, bytesRemaining,</span><br><span class="line">                       blkLocations[blkIndex].getHosts(),</span><br><span class="line">                       blkLocations[blkIndex].getCachedHosts()));</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// not splitable		//不可分片的输入</span></span><br><span class="line">          splits.add(makeSplit(path, <span class="number">0</span>, length, blkLocations[<span class="number">0</span>].getHosts(),</span><br><span class="line">                      blkLocations[<span class="number">0</span>].getCachedHosts()));</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p>
<p>注意getSplits时有个“可分片”的概念，也就是isSplitable。分片的意思是，对于单独一个分片，可以独立的拿给对应的Map任务处理，分片之间无依赖。<br>是否所有的Input都是可以分片的呢？对于纯文本来说，从任何一个位置都是可以直接读取的，显然是可分片的；但是对于gz压缩的文件来说，如果我们只拿到了一个分片，是没办法只解压这一个分片的（因为gz压缩是将压缩信息存储到所有分片的，只有一个分片不能得到所有的压缩信息，无法解压）。hadoop的做法其实就是根据文件后缀名来查找codec，然后检查是否<code>codec instanceof SplittableCompressionCodec;</code>。isSplitable是可以@override的。<br><strong>可分片的Input处理方法：</strong></p>
<ul>
<li>确定分片大小。通过<code>file.getBlockSize()</code>获取HDFS的block大小，然后跟MR自己定义的最大最小值比较来选择一个中间值。MR的最大最小值默认是Long.MAX_VALUE/1，所在wordcount里确定的split大小实际就是HDFS的blck大小。</li>
<li>根据文件的总大小，先分整个split大小的，剩余的单独一个分片。每个分片都add到splits数组，add时会获取该block所在的节点地址（有缓存的时候优先使用缓存节点），提交Job后在分配Map任务时会参考这个节点地址，这样就可以将Map任务分配到数据所在的节点上（数据本地）。</li>
</ul>
<p><strong>对于不可分片的Input处理方法：</strong><br>只add一次，节点就是第一个分片的节点地址。所以对于不可分片的文件，其实是损失了MR的并行运行，多个分片也需要跨节点拷贝，效率比较低。</p>
<p>具体到wordcount，由于我们输入的文件是纯文本的，所以可以分片；而客户端会根据HDFS各个分片所在的节点地址分别添加到待启动的各个MR任务上，任务总数会写到<code>MRJobConfig.NUM_MAPS</code>，提交了以后使用。</p>
<p>至此，我们明确了Map任务个数的确定者以及其确定阶段。<br>下期预告：第二个问题也是大家经常问的一个，HDFS的block是否粗暴但忠实的将文件按照64MB分片呢？如果是的话，怎么保证Map获取到的Splits是正确的？具体到wordcount，MR是怎么处理一个单词跨block的情况呢？</p>

      
    </div>
    <footer>
      
        
        
  
  <div class="tags">
    <a href="/tags/hadoop/">hadoop</a>
  </div>

        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>


<section id="comment">
	<div class="ds-thread"></div>
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"silenceshell"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
</section>

</div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
<form>
    <input type="text" id="ts-search-input"  name="word" maxlength="20"  class="search-form-input" placeholder="Search">
</form>
</div>

  

  
<div class="widget tag">
  <h3 class="title">標籤</h3>
  <ul class="entry">
  
    <li><a href="/tags/PALO/">PALO</a><small>1</small></li>
  
    <li><a href="/tags/ambari/">ambari</a><small>1</small></li>
  
    <li><a href="/tags/baidu/">baidu</a><small>1</small></li>
  
    <li><a href="/tags/hadoop/">hadoop</a><small>9</small></li>
  
    <li><a href="/tags/hdfs/">hdfs</a><small>1</small></li>
  
    <li><a href="/tags/hibernate/">hibernate</a><small>1</small></li>
  
    <li><a href="/tags/hive/">hive</a><small>1</small></li>
  
    <li><a href="/tags/keepalived/">keepalived</a><small>1</small></li>
  
    <li><a href="/tags/mesos/">mesos</a><small>1</small></li>
  
    <li><a href="/tags/nginx/">nginx</a><small>1</small></li>
  
    <li><a href="/tags/olap/">olap</a><small>1</small></li>
  
    <li><a href="/tags/python/">python</a><small>2</small></li>
  
    <li><a href="/tags/spark/">spark</a><small>1</small></li>
  
    <li><a href="/tags/sqoop/">sqoop</a><small>1</small></li>
  
    <li><a href="/tags/storm/">storm</a><small>1</small></li>
  
    <li><a href="/tags/tez/">tez</a><small>1</small></li>
  
    <li><a href="/tags/yarn/">yarn</a><small>2</small></li>
  
  </ul>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2015 hubt@dtdream.com
  
</div>
<div class="clearfix"></div></footer>
  <script src="//libs.baidu.com/jquery/2.0.3/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

</body>
</html>