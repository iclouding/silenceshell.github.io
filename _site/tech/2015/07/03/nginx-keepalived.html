<!DOCTYPE html>
<html>

	<script>
	var _hmt = _hmt || [];
	(function() {
	  var hm = document.createElement("script");
	  hm.src = "//hm.baidu.com/hm.js?28bfa356a7c60e170822a01142cf208e";
	  var s = document.getElementsByTagName("script")[0]; 
	  s.parentNode.insertBefore(hm, s);
	})();
	</script>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>使用nginx+keepalived实现RESTful API服务器的负载均衡和高可靠性</title>
  <meta name="description" content="核心需求是我们有一个RESTful API的服务集群，需要能够保证不管是web服务故障还是服务器整体故障，外部访问不会间断，并且在整体运行正常的时候，需要能够负载均衡。业界比较常见的几个负载均衡方案有haproxy, nginx, lvs。有关这仨的比较，可以看这篇文章。我这里选择的方案是nginx+keepal...">
  
  <meta name="author" content="伊布">
  <meta name="copyright" content="&copy; 伊布 2016">
  

  <!-- External libraries -->
  <!--<link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css"> -->
  <link href="//cdn.bootcss.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet">
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.1.0/styles/solarized-dark.min.css">
  <!--<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.5/styles/monokai_sublime.min.css">-->
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/lightbox2/2.7.1/css/lightbox.css">

  <!-- Favicon and other icons (made with http://www.favicon-generator.org/) -->
  <link rel="shortcut icon" href="/assets/icons/favicon.ico" type="image/x-icon">
  <link rel="icon" href="/assets/icons/favicon.ico" type="image/x-icon">
  <link rel="apple-touch-icon" sizes="57x57" href="/assets/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/assets/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/assets/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/assets/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/assets/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/assets/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/assets/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/assets/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/assets/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192"  href="/assets/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/assets/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/assets/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/assets/icons/favicon-16x16.png">
  <link rel="manifest" href="/assets/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/assets/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">

  
  <!-- Facebook OGP cards -->
  <meta property="og:description" content="核心需求是我们有一个RESTful API的服务集群，需要能够保证不管是web服务故障还是服务器整体故障，外部访问不会间断，并且在整体运行正常的时候，需要能够负载均衡。业界比较常见的几个负载均衡方案有haproxy, nginx, lvs。有关这仨的比较，可以看这篇文章。我这里选择的方案是nginx+keepal..." />
  <meta property="og:url" content="http://silenceshell.gitcafe.io" />
  <meta property="og:site_name" content="Zlatan Eevee" />
  <meta property="og:title" content="使用nginx+keepalived实现RESTful API服务器的负载均衡和高可靠性" />
  <meta property="og:type" content="website" />
  <meta property="og:image" content="http://silenceshell.gitcafe.io/assets/instacode.png" />
  <meta property="og:image:type" content="image/png" />
  <meta property="og:image:width" content="612" />
  <meta property="og:image:height" content="605" />
  

  
  <!-- Twitter: card tags -->
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="使用nginx+keepalived实现RESTful API服务器的负载均衡和高可靠性">
  <meta name="twitter:description" content="核心需求是我们有一个RESTful API的服务集群，需要能够保证不管是web服务故障还是服务器整体故障，外部访问不会间断，并且在整体运行正常的时候，需要能够负载均衡。业界比较常见的几个负载均衡方案有haproxy, nginx, lvs。有关这仨的比较，可以看这篇文章。我这里选择的方案是nginx+keepal...">
  <meta name="twitter:image" content="http://silenceshell.gitcafe.io/assets/instacode.png">
  <meta name="twitter:url" content="http://silenceshell.gitcafe.io">
  

  

  <!-- Site styles -->
  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="http://silenceshell.gitcafe.io/tech/2015/07/03/nginx-keepalived.html">
  <link rel="alternate" type="application/rss+xml" title="Zlatan Eevee" href="http://silenceshell.gitcafe.io/feed.xml" />
</head>


  <body>

    <header class="navigation" role="banner">
  <div class="navigation-wrapper">
    <a href="/" class="logo">
      
      <img src="/assets/logo.png" alt="Zlatan Eevee">
      
    </a>
    <a href="javascript:void(0)" class="navigation-menu-button" id="js-mobile-menu">
      <i class="fa fa-bars"></i>
    </a>
    <nav role="navigation">
      <ul id="js-navigation-menu" class="navigation-menu show">
        
          
          <li class="nav-link"><a href="/about/">About</a>
          
        
          
        
          
        
          
        
          
          <li class="nav-link"><a href="/posts/">Posts</a>
          
        
          
          <li class="nav-link"><a href="/typography/">Typography</a>
          
        
          
        
          
        
          
        
          
        
          
        
          
        
      </ul>
    </nav>
  </div>
</header>


    <div class="page-content">
        <div class="post">

<div class="post-header-container has-cover" style="background-image: url(/assets/instacode.png);">
  <div class="scrim has-cover">
    <header class="post-header">
      <h1 class="title">使用nginx+keepalived实现RESTful API服务器的负载均衡和高可靠性</h1>
      <p class="info">by <strong>伊布</strong></p>
    </header>
  </div>
</div>

<div class="wrapper">



<section class="post-meta">
  <div class="post-date">July 3, 2015</div>
  <div class="post-categories">
  in 
    
    <a href="/category/tech">Tech</a>
    
  
  </div>
</section>  

<article class="post-content">
  <p>核心需求是我们有一个RESTful API的服务集群，需要能够保证不管是web服务故障还是服务器整体故障，外部访问不会间断，并且在整体运行正常的时候，需要能够负载均衡。
业界比较常见的几个负载均衡方案有haproxy, nginx, lvs。有关这仨的比较，可以看<a href="http://www.csdn.net/article/2014-07-24/2820837">这篇文章</a>。我这里选择的方案是nginx+keepalived。nginx做反向代理，可以实现负载均衡，如果后端的web服务故障了，nginx可以实现切换；但nginx本身存在单点故障，需要通过keepalived监测实现nginx的切换。</p>

<p>整体结构图
<img src="http://7xir15.com1.z0.glb.clouddn.com/nginx反向代理.png" alt="" /></p>

<h2 id="nginxrepo">1、设置nginx.repo：</h2>
<p>我用的操作系统是centos6.5，如下：</p>

<p><code class="highlighter-rouge">bash
[nginx]
name=nginx repo
baseurl=http://nginx.org/packages/centos/$releasever/$basearch/
gpgcheck=0
enabled=1
</code></p>

<p>如果是RHEL:</p>

<p><code class="highlighter-rouge">bash
[nginx]
name=nginx repo
baseurl=http://nginx.org/packages/rhel/$releasever/$basearch/
gpgcheck=0
enabled=1
</code></p>

<h2 id="nginxkeepalived">2、安装nginx、keepalived</h2>

<p><code class="highlighter-rouge">bash
$ yum install nginx
$ yum install keepalived
</code></p>

<p>安装完毕后两个服务都是停止的，需要start并加到系统启动服务中。</p>

<p><code class="highlighter-rouge">bash
$ chkconfig  nginx on
$ chkconfig  keepalived on
</code></p>

<p>nginx启动后，默认会有一个http server，例如我这里访问的地址是<code class="highlighter-rouge">http://192.168.80.165</code>和<code class="highlighter-rouge">http://192.168.80.166</code>，两台服务器的地址。但实际上我不需要这俩web服务器，而是需要让nginx做反向代理，将http请求导引到我的RESTful API服务器上，配置下面会有提到。</p>

<h2 id="keepalived">3、修改keepalived的配置文件</h2>
<p>配置文件的路径是<code class="highlighter-rouge">/etc/keepalived/keepalived.conf</code>。
master：</p>

<p><code class="highlighter-rouge">bash
vrrp_instance VI_1 {
    state MASTER
    interface eth2   #具体的网卡
    virtual_router_id 51
    priority 101
    advert_int 1
    authentication {
        auth_type PASS
        auth_pass 1111
    }
    virtual_ipaddress {
        192.168.80.111
    }
}
</code></p>

<p>slave：</p>

<p><code class="highlighter-rouge">bash
vrrp_instance VI_1 {
    state MASTER
    interface eth4   #具体的网卡
    virtual_router_id 51
    priority 100     #比master小
    advert_int 1
    authentication {
        auth_type PASS
        auth_pass 1111
    }
    virtual_ipaddress {
        192.168.80.111
    }
}
</code></p>

<p>其他的virtual server等信息都删掉，那是给lvs用的。
配置完毕后，重启两台服务器上的keepalived进程，在master上可以看到我们配置的虚IP（ifconfig看不到）。将master上keepalived服务stop掉，可以看到虚IP跑到slave上了；再启动master上keepalived进程，虚IP会被master抢占回来，因为master的priority更大。</p>

<p><code class="highlighter-rouge">bash
# ip add
...
2: eth2: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP qlen 1000
    link/ether 00:0c:29:73:f6:15 brd ff:ff:ff:ff:ff:ff
    inet 192.168.80.165/24 brd 192.168.80.255 scope global eth2
    inet 192.168.80.111/32 scope global eth2
</code></p>

<h2 id="nginx">4、使用脚本检测nginx服务</h2>
<p>上面的配置可以保证keepalived关闭（例如服务器故障）时，虚IP自动切换；但有的时候可能只是web服务故障了，我们希望的是keepalived检测服务的状态，并且能够自动切换。这种情况可以用脚本来检测nginx服务状态，根据检测结果调高或调低vrrp的优先级，达到虚IP切换的目的。
新建一个探测脚本：check_nginx.sh</p>

<p><code class="highlighter-rouge">bash
#!/bin/bash
netstat -antp|grep nginx
exit $?
</code></p>

<p>修改keepalived.conf：</p>

<p><code class="highlighter-rouge">bash
vrrp_script check_succ {
    script "/etc/keepalived/check_nginx.sh"
    interval 1
    weight -5
    fall 3
}
vrrp_script check_fail {
    script "/etc/keepalived/check_nginx.sh"
    interval 1
    weight 5
    rise 2
}
vrrp_instance VI_1 {
...
    track_script {
       check_succ
       check_fail
    }
</code></p>

<p>据说探测成功或失败了以后只会改一次优先级，所以不要担心不停探测优先级一直增长的问题。
简单说明下，上面的脚本简单的检查了nginx是不是还在监听端口，如果发现不是（例如主的nginx被stop），则priority-5，vrrp通告出去后，备发现自己的优先级更高，vrrp切换，备抢占虚IP，此时访问的nginx就是备上的了；等到主nginx重新启动后，脚本检查端口已在监听，则priority+5，vrrp切换，主会重新抢占虚IP，达到HA的目的。</p>

<h2 id="nginx-1">5、配置nginx</h2>
<p>上面配置完keepalived后，HA的功能完成了，但是用户只能访问一个服务器，对于有多个web容器的情况就无能为力了，这时候需要nginx出马。
nginx在我们的组网里实际是一个loadbalance的角色，将用户的请求分发给不同的server（即upstream）。由于我们后端服务器监听的是8443 ssl端口，所以步骤稍微复杂一点。
###5.1 配置nginx
CENTOS6.5的nginx配置是在<code class="highlighter-rouge">/etc/nginx/conf.d/default</code>，我直接给出配置（基本是照抄了以升的说明）：</p>

<p>```bash
upstream dxt
{
        server 192.168.80.165:8443;   #负载分担的两个服务器,
        server 192.168.80.166:8443;   #也就是我这里的rest api服务，分在两台服务器上
}</p>

<p>server {
    listen       443 ssl;			#由于nginx和restapi服务在同一台服务器上，需要使用不同的端口
    server_name  192.168.80.111;	#虚IP</p>

<div class="highlighter-rouge"><pre class="highlight"><code>root html;
index index.html index.htm;

ssl on;							#配置ssl
ssl_certificate server.crt;
ssl_certificate_key server.key;
ssl_session_timeout 5m;

ssl_protocols SSLv3 TLSv1 TLSv1.1 TLSv1.2;
ssl_ciphers "HIGH:!aNULL:!MD5 or HIGH:!aNULL:!MD5:!3DES";
ssl_prefer_server_ciphers on;

location /api/ {				#只处理/api这个路径
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header Host $host;
    proxy_set_header X-NginX-Proxy true;

    proxy_pass https://dxt;		#指定upstream
    proxy_redirect off;
} } ```
</code></pre>
</div>

<h3 id="sslservercrtserverkey">5.2 配置ssl需要的server.crt、server.key</h3>
<p>使用ssl还需要两个证书文件，这里也按照以升给出的方法生成。</p>

<p><code class="highlighter-rouge">bash
# cd /etc/nginx
# openssl genrsa -des3 -out server.key 1024
# openssl req -new -key server.key -out server.csr
# cp server.key server.key.org
# openssl rsa -in server.key.org -out server.key
# openssl x509 -req -days 365 -in server.csr -signkey server.key -out server.crt
</code></p>

<p>配置后重启nginx，浏览器访问<code class="highlighter-rouge">https://192.168.80.111:443/api/</code>，应该可以看到restapi的信息了。</p>

<h3 id="section">5.3 坑</h3>
<p>！！但是这里有个坑，如果你跟我一样也是用的centos6.5，会发现浏览器返回的是这样的：
<img src="http://7xir15.com1.z0.glb.clouddn.com/nginx错误.png" alt="nginx错误信息" />
说明还停留在nginx上，反向代理失败了。
去查nginx的日志<code class="highlighter-rouge">/var/log/nginx/error.log</code>，看到下面的信息：</p>

<p><code class="highlighter-rouge">bash
2015/07/02 09:52:12 [error] 15053#0: *8 SSL_do_handshake() failed (SSL: error:100AE081:elliptic curve routines:EC_GROUP_new_by_curve_name:unknown group error:1408D010:SSL routines:SSL3_GET_KEY_EXCHANGE:EC lib) while SSL handshaking to upstream, client: 192.168.80.1, server: 192.168.80.111, request: "GET /api/ HTTP/1.1", upstream: "https://192.168.80.166:8443/api/", host: "192.168.80.111"
</code></p>

<p>查了一下，说这是centos6.5上默认openssl版本的错误，需要更新openssl的版本。可以查看<a href="http://zh.hortonworks.com/community/forums/topic/ambari-agent-registration-failure-on-rhel-6-5-due-to-openssl-2/">这篇文章</a>，或者你懒的看，直接<code class="highlighter-rouge">yum update openssl</code>即可。
升级以后的版本应该是这个：</p>

<p><code class="highlighter-rouge">bash
# rpm -aq|grep openssl
openssl-1.0.1e-30.el6.11.x86_64
</code></p>

<p>升级完毕后再重启一下nginx，现在访问虚IP，就能看到restapi的信息了。如果你用POSTMAN这种restapi客户端打几次请求，从rest server日志里可以看到是轮询访问不同的rest server。
<img src="http://7xir15.com1.z0.glb.clouddn.com/虚IP.png" alt="" /></p>

<hr />

<p>通过上面的keepalived和nginx的配置，我们完成了开始预设的要求：
1. rest server能够负载分担；
2. 某rest server进程故障，可以由nginx剔除；
3. nginx故障，keepalived可以切换虚IP到正常nginx，由新的nginx继续负载分担；nginx故障恢复，切换回原来的主server；
4. 整设备故障，vrrp超时切换虚IP到正常服务器；故障恢复，回切。</p>

</article>



<section class="tags">
  <strong>Tags:</strong> <a href="/tag/nginx">nginx</a>,&nbsp;<a href="/tag/keepalived">keepalived</a>
</section>



<section class="rss">
  <p class="rss-subscribe text"><strong>Subscribe <a href="/feed.xml">via RSS</a></strong></p>
</section>

<section class="share">
  <span>Share: </span>
  
    
    
      <a href="//twitter.com/share?text=%E4%BD%BF%E7%94%A8nginx%2Bkeepalived%E5%AE%9E%E7%8E%B0RESTful+API%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%92%8C%E9%AB%98%E5%8F%AF%E9%9D%A0%E6%80%A7&url=http://silenceshell.gitcafe.io/tech/2015/07/03/nginx-keepalived.html&via=瓶子"
        onclick="window.open(this.href, 'twitter-share', 'width=550,height=255');return false;">
        <i class="fa fa-twitter-square fa-lg"></i>
      </a>
    
    
    
    
    
  
    
    
    
    
    
    
  
</section>



</div>
</div>

    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h3 class="footer-heading">Zlatan Eevee</h3>

    <div class="site-navigation">
      
      <p><strong>Site Map</strong></p>
      <ul class="pages">
        
        
          <li class="nav-link"><a href="/about/">About</a>
        
        
        
        
        
        
        
        
        
          <li class="nav-link"><a href="/posts/">Posts</a>
        
        
        
          <li class="nav-link"><a href="/typography/">Typography</a>
        
        
        
        
        
        
        
        
        
        
        
        
        
        
      </ul>
    </div>

    <div class="site-contact">

      <p><strong>Contact</strong></p>
      <ul class="social-media-list">
        <li>
          <a href="mailto:hubottle@gmail.com">
            <i class="fa fa-envelope-o"></i>
            <span class="username">hubottle@gmail.com</span>
          </a>
        </li>

        
          
          <li>
            <a href="https://twitter.com/hubottle" title="Follow me on Twitter">
              <i class="fa fa-twitter"></i>
              <span class="username">瓶子</span>
            </a>
          </li>
          
        
          
          <li>
            <a href="https://github.com/silenceshell" title="Fork me on GitHub">
              <i class="fa fa-github"></i>
              <span class="username">silenceshell</span>
            </a>
          </li>
          
        

      </ul>
    </div>

    <div class="site-signature">
      <p class="rss-subscribe text"><strong>Subscribe <a href="/feed.xml">via RSS</a></strong></p>
      <p class="text"></p>
    </div>

  </div>

</footer>

<!-- Scripts -->
<script src="//code.jquery.com/jquery-1.11.2.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.5/highlight.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/lightbox2/2.7.1/js/lightbox.min.js"></script>
<script>

$(document).ready(function() {

  // Syntax highlighting
  hljs.initHighlightingOnLoad();

  // Header
  var menuToggle = $('#js-mobile-menu').unbind();
  $('#js-navigation-menu').removeClass("show");
  menuToggle.on('click', function(e) {
    e.preventDefault();
    $('#js-navigation-menu').slideToggle(function(){
      if($('#js-navigation-menu').is(':hidden')) {
        $('#js-navigation-menu').removeAttr('style');
      }
    });
  });


});

</script>




  </body>

</html>
